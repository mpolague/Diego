# Diego
Exam 2

Stone Game:
Define the problem/solution: The recursion for dp(i,j) can be formulated by using dp(i+1) and dp(i,j-1). ‘i’ symbolizes the first pile of stones and ‘j’ symbolizes the last pile of stones. When the player takes the first pile of stones, we use dp(i+1,j) because the first pile of stones was taken, if the player takes the last pile of stones we use dp(i,j-1) because the last pile of stones was taken. 
The way to solve the global problem is to return the maximum of (i,j). I checked if the current player was Alex or if it was Lee so that way I could determine if the player should take the pile of stones with the greatest amount of if the user should take the pile of stones with the least amount. If the current player was Alex, I returned the maximum of the first pile of stones and the last pile of stones.
I first identified the problem. I made sure I knew exactly what the problem was asking me to do. I then Defined my goals by making sure Alex always won the game no matter what. I explored strategies such as keeping a counter for what the players had as points. I then changed it up a bit and returned the maximum of the two piles so Alex could win. Since there were two players, I anticipated that I needed to take the minimum of the two piles so Alex could take the maximum when it was his turn. Look and Learn: I realized that using dynamic programming wasn’t as difficult as it sounds. In fact, I believe it made the problem a little easier. 
I worked small instances by hand such as drawing the pile of stones and taking the maximum of the two piles each time it was Alex’s turn. I wrote down ideas of what I wanted to do to get the maximum piles when it was Alex’s turn. The only pattern I could find was that Alex was always going to be taking the maximum of the two piles. As I said before, I drew the pile of stones and started taking the maximum of those two, and that is how I checked by hand. Instead of me translating the pseudo code to code, I translated the code into pseudo code so I could understand it better. I ran test cases, I tried different instances of piles to see if it always worked and it did. There were no failed test cases so I did not have to debug.

---------------------------------------------

Palindromic Substrings:
Define the problem/solution: The recursion for dp[i][j] can be formulated by using dp[i][j-1]+dp[i+1][j]+1-dp[i+1][j-1] and with dp[i][j-1]+dp[i+1][j]-dp[i+1][j-1]. With these formulas, I will be adding the palindromes I have so far, or I will not be adding any palindrome if the letters I have seen so far are not palindromic. 
I first created a 2-D matrix that counts all palindrome substrings that exist within the string that was given to me. I created another 2-D matrix that has all values set to False so I could change it to a value of True if the string was palindrome. I then added a value of True for every letter because every letter is considered a palindrome. After I iterate through all the string, I returned the total of the palindromic substrings.
I first identified what the problem asked for me to do. I defined my goal of how to save the number of palindrome substrings. I explored strategies. I tried different ways to keep a counter to count the palindrome substrings. I anticipated to run into problems such as how to save the palindrome substrings and the counter at the same time, a 2-D array seemed a good way to store values. Look and Learn: I would have never thought of solving this problem with a 2-D array. I now believe that I will be more open with using 2-D arrays to solve problems like these.
I worked instances by hand, such as the examples that were given to us with Exam 2. I also made up some problems myself. I wrote down notes on what exactly I did so I could follow those same steps for other instances. I found some patterns such as counting every single letter as a palindrome. I translated the code I found to pseudo code so it made it easier for me to understand. I ran test cases by providing the code with different types of words such as long words and short words.

------------------------------------------------------

Minimum Ascii:
Define the problem/solution: The recursion for dp[i][j] = dp[i+1][j+1] if and only if the length of both strings equal to each other. If they don’t equal to each other, I have to use dp[i][j] = min(dp[i+1][j]+ord(s1[i]),dp[i][j+1]+ord(s2[j])). I use this formula so I can return the minimum of the ascii characters between the two strings that were given to me. 
The way I solved the problem was using a for loop that iterates through string 1 and another for loop that iterates through string 2. I checked if the index at i equaled the index at i of string 2, if they didn’t, I found the lowest ASCII sum of deleted characters to make both strings equal to each other. I returned the minimum of the ascii characters between the two strings that were given to me.
I first identified what the problem was asking. I then defined my goal, which was trying to find the mimum of the ascii values. I explored ways to solve the problem. I wasn’t sure on how to save the minimum ascii value needed to solve the problem. I anticipated getting errors when many different words were given to me because that would’ve caused many problems since my test cases would fail. Look and Learn: I thought this problem would be worse but it was actually not that bad. I just had to find the minimum of the ascii values and work with that.
As I said before, I worked some small instances such as trying my test cases with different strings. I wrote down what I did so I could follow those same rules I applied to a different scenario. I personally did not find any other pattern. I translated the code I found online to pseudo code so I could try and attack it with my own instances of strings to see if it worked or not. Since there were no bugs, I did not have to debug failed test cases.

------------------------------------------------

Maximum Length of Pair Chain:
Define the problem/solution: The recursion for dp[i] can be formulated by using max(dp[i],dp[j]+1). Let’s say that dp[j] represents the longest chain so far (inclusive). Whenever j is less than i, it means that the chain has been broken so we use max(dp[i],dp[j]+1) to find the maximum pair chain.
I first sorted the pairs and then created an array with default values of 1 of the length of the pairs. I iterated through the pairs and compared the pairs.
I identified the problem, as always. I then defined my goals which were to iterate through the pairs and compare the elements within it and so on. I explored ways that I could keep track of the counter that helped me identify the length of the longest chain. I anticipated problems such as no chain existing or if the entire list of pairs were all valid. Look and Learn: This problem was easy to follow. Dynamic programming for this problem makes it seem like dynamic programming isn’t that bad. 
I worked some instances such as the ones I listed above. I checked if my test cases passed when the list was not valid at all or if the entire list of pairs was valid. I wrote down what I did so I could use those same steps for some other instances. The only pattern I was able to find was if the counter was broken by another longest chain. I checked by hand different instances that I thought could make my test cases fail. I translated the code I found online to pseudo code to understand it better. I ran test cases with different instances to see if they would make my test cases fail. There were no failed test cases so I did not have to debug.

------------------------------------

Integer Break:
Define the problem/solution: The recursion for dp[i] can be formulated by using max(max(i-j,dp[i-j])*j for j in range(1,i)). This formula is meant to extract the numbers that add up to that number so it is able to maximize the product of that given number. After finding the numbers that add up to the given number, I multiplied the numbers and returned the product of them.
As I have mentioned before. I found the numbers that add up to the number using a for loop. I then multiplied the numbers that add up to the given number and multiplied them and returned it.
I first identified how the problem found the numbers that add up to the given number. I then defined my goals of how I wanted to maximize the product of those integers. I explored ways on how to keep track of the product of the numbers by using arrays and a counter. I anticipated outcomes such as having different combinations of numbers that add up to the given number and then changed the code in a way that allowed me to use the numbers I wanted. Look and Learn: I know I have said this before, but I would have not thought of this as a solution for the problem. I believe this is a short and sweet way to solving this problem. 
I worked small instances by hand of numbers that had different number combinations that added up to that number. I wrote down the pseudo code that the code I found was doing so I could understand it better and be able to trace it. I checked by hand the possible combination of numbers that added up to those numbers. And as I said before, I translated the code into pseudo code so I could understand what the code was doing; it helped me trace it. I ran test cases of different combinations of numbers. I did not find any bug so I didn’t have to debug the failed test cases.
